parameters:
  environmentName: ''
  environmentnumber: ''
  azureDevOpsServiceConnection: ''
  containerRegistry: ''
  appResourceGroup: ''
  imageRepository: ''
  appName: ''
  imageTag: ''
  imageBuildNumber: ''
  healthCheckPath: '/health'

steps:
- ${{ if ne(variables['Build.SourceBranch'], 'refs/heads/master') }}:
  - task: PowerShell@2
    condition: succeeded()
    displayName: 'Tag Image as latest and Push'
    inputs:
      targetType: inline
      script: |
        $oldImageName = "{0}.azurecr.io/{1}:{2}" -f $env:ACR_NAME, $env:DOCKER_REPO, $env:DOCKER_TAG
        $newImageName = "{0}.azurecr.io/{1}:latest-{2}{3}" -f $env:ACR_NAME, $env:DOCKER_REPO, $env:ENV_NAME, $env:ENV_NUMBER
        
        docker pull $oldImageName
        docker tag $oldImageName $newImageName
        docker push $newImageName

        Write-Output "Re-tagging [$oldImageName] as [$newImageName] .."
    env:
      ACR_NAME: ${{ parameters.containerRegistry }}
      DOCKER_REPO: ${{ parameters.imageRepository }}
      DOCKER_TAG: ${{ parameters.imageTag }}
      ENV_NAME: ${{ parameters.environmentName }}
      ENV_NUMBER: ${{ parameters.environmentnumber }}

- ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
  - task: AzureKeyVault@1
    condition: succeeded()
    displayName: 'Retrieve Signing Key'
    inputs:
      azureSubscription: '$(prodUatAzureRMServiceConnection)'
      keyVaultName: 'mapaersprodsecrets'
      secretsFilter: 'acr-repo-ci-signing-key-passphrase, acr-repo-ci-signing-key, acr-repo-ci-signing-key-filename'
    continueOnError: false

  - task: AzureCLI@2
    displayName: 'ACR Image Signer Auth'
    inputs:
      azureSubscription: '$(prodUatAzureRMServiceConnection)'
      scriptType: pscore
      scriptLocation: inlineScript
      addSpnToEnvironment: true
      inlineScript: |
        az acr login -n ${{ parameters.containerRegistry }}

  - task: PowerShell@2
    condition: succeeded()
    displayName: 'Tag Image as latest and Push'
    inputs:
      targetType: inline
      script: |
        mkdir -p $(DOCKER_CONFIG)/trust/private
        [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($env:KEY_BASE64)) | Out-File -FilePath $(DOCKER_CONFIG)/trust/private/$env:KEY_FILENAME.key

        $oldImageName = "{0}.azurecr.io/{1}:{2}" -f $env:ACR_NAME, $env:DOCKER_REPO, $env:DOCKER_TAG
        $newImageName = "{0}.azurecr.io/{1}:latest-{2}{3}" -f $env:ACR_NAME, $env:DOCKER_REPO, $env:ENV_NAME, $env:ENV_NUMBER

        Write-Output "Re-tagging [$oldImageName] as [$newImageName] .."

        docker pull $oldImageName

        # Validate that the image was signed by the 'ers-ci' pipeline key
        $trustResponse = docker trust inspect $oldImageName | ConvertFrom-JSON
        $rootKeyHash = ($trustResponse.Signers | where {$_.Name -eq "ers-ci" }).Keys.ID
        if ($rootKeyHash -ne $env:KNOWN_SIGNERHASH) {
          Write-Output "Unexpected ACR Root Key in image."
          exit 1
        }

        docker tag $oldImageName $newImageName
        docker push $newImageName
    env:
      DOCKER_CONTENT_TRUST: 1 # Force DCT for all docker commands
      DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE: $(acr-repo-ci-signing-key-passphrase)
      KEY_BASE64: $(acr-repo-ci-signing-key)
      KEY_FILENAME: $(acr-repo-ci-signing-key-filename)
      KNOWN_SIGNERHASH: $(acr-repo-ci-signing-key-filename)
      ACR_NAME: ${{ parameters.containerRegistry }}
      DOCKER_REPO: ${{ parameters.imageRepository }}
      DOCKER_TAG: ${{ parameters.imageTag }}
      ENV_NAME: ${{ parameters.environmentName }}
      ENV_NUMBER: ${{ parameters.environmentnumber }}

- bash: |
    export TZ="Pacific/Auckland" 
    currentDateTime="$(date '+%a %d %b %Y %T %Z')"
    echo "Release timestamp: $currentDateTime"
    echo "##vso[task.setvariable variable=currentDateTime]$currentDateTime"
  displayName: 'Get current timestamp'

- task: AzureRMWebAppDeployment@4
  displayName: 'Deploy Container to App Service' 
  name: WebAppDeployment
  inputs:
    appType: webAppContainer
    ConnectedServiceName: ${{ parameters.azureDevOpsServiceConnection }}
    WebAppName: ${{ parameters.appName }}
    ResourceGroupName: ${{ parameters.appResourceGroup }}
    DockerNamespace: '${{ parameters.containerRegistry }}.azurecr.io'
    DockerRepository: ${{ parameters.imageRepository }}
    DockerImageTag: latest-${{ parameters.environmentName }}${{ parameters.environmentnumber }}
    AppSettings: -ReleaseDate "$(currentDateTime)"

- pwsh: |
    Write-Output "WebApp URL: $(WebAppDeployment.AppServiceApplicationUrl)"
    $healthCheckURL =  "$(WebAppDeployment.AppServiceApplicationUrl)${{ parameters.healthCheckPath }}"
    # Simple WebApp Readiness Check
    # Wait 5 minute(s) for this to be ready
    $timeout = new-timespan -Minutes 5
    $sw = [diagnostics.stopwatch]::StartNew()
    while ($sw.elapsed -lt $timeout){
      try {
        $result = Invoke-RestMethod -Method 'GET' -Uri $healthCheckURL
        if ( ($result.status -eq "Healthy") -And ($result.healthy.EntryAssemblyVersion -eq $env:webAppVersion) ) {
          Write-Output "Successfully deployed: $($result.healthy.EntryAssemblyVersion)"
          exit 0
        }
      }
      catch {
        Write-Output "Exception calling healthcheck URL: $healthCheckURL"
      }
      start-sleep -seconds 10
    }
    Write-Output "Timed out waiting for successful deployment: $($result.healthy.EntryAssemblyVersion); expected: $env:webAppVersion"
    exit 1
  displayName: Checking for successful deployment
  continueOnError: false
  env:
    webAppVersion: ${{ parameters.imageBuildNumber }}